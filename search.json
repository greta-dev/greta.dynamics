[{"path":"https://greta-dev.github.io/greta.dynamics/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Nick Golding. Author, maintainer.","code":""},{"path":"https://greta-dev.github.io/greta.dynamics/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Golding N (2022). greta.dynamics: Modelling Structured Dynamical Systems greta. https://github.com/greta-dev/greta.dynamics, https://greta-dev.github.io/greta.dynamics/.","code":"@Manual{,   title = {greta.dynamics: Modelling Structured Dynamical Systems in greta},   author = {Nick Golding},   year = {2022},   note = {https://github.com/greta-dev/greta.dynamics, https://greta-dev.github.io/greta.dynamics/}, }"},{"path":[]},{"path":"https://greta-dev.github.io/greta.dynamics/index.html","id":"dynamical-models-in-greta","dir":"","previous_headings":"greta.dynamics","what":"Dynamical models in greta","title":"Modelling Structured Dynamical Systems in greta","text":"greta.dynamics provides functions modelling dynamical systems greta. work progress, currently provides functions analysing transition matrices iteration, solving ordinary differential equations.","code":""},{"path":"https://greta-dev.github.io/greta.dynamics/reference/greta.dynamics.html","id":null,"dir":"Reference","previous_headings":"","what":"greta.dynamics: a greta extension for modelling dynamical systems — greta.dynamics","title":"greta.dynamics: a greta extension for modelling dynamical systems — greta.dynamics","text":"extension greta functions simulating dynamical systems, defined ordinary differential equations (see ode_solve()) transition matrices (iterate_matrix()).","code":""},{"path":"https://greta-dev.github.io/greta.dynamics/reference/iterate_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"iterate transition matrices — iterate_matrix","title":"iterate transition matrices — iterate_matrix","text":"Calculate intrinsic growth rate(s) stable stage distribution(s) stage-structured dynamical system, encoded state_t = matrix \\%*\\% state_tm1.","code":""},{"path":"https://greta-dev.github.io/greta.dynamics/reference/iterate_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"iterate transition matrices — iterate_matrix","text":"","code":"iterate_matrix(   matrix,   initial_state = rep(1, ncol(matrix)),   niter = 100,   tol = 1e-06 )"},{"path":"https://greta-dev.github.io/greta.dynamics/reference/iterate_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"iterate transition matrices — iterate_matrix","text":"matrix either square 2D transition matrix (dimensions m x m), 3D array (dimensions n x m x m), giving one transition matrices iterate initial_state either column vector (m elements) 3D array (dimensions n x m x 1) giving one initial states iterate matrix niter positive integer giving maximum number times iterate matrix tol scalar giving numerical tolerance, algorithm determineed converged growth rate stages","code":""},{"path":"https://greta-dev.github.io/greta.dynamics/reference/iterate_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"iterate transition matrices — iterate_matrix","text":"named list five greta arrays: lambda scalar vector giving ratio first stage values final two iterations. stable_state vector matrix (dimensions initial_state) giving state final iteration, normalised values stages sum one. all_states n x m x niter matrix state values iteration. 0 entries iterations. converged integer scalar vector indicating whether iterations matrix converged tolerance less tol (1 , 0 ) algorithm finished. iterations scalar maximum number iterations completed algorithm terminated. match niter converged FALSE.","code":""},{"path":"https://greta-dev.github.io/greta.dynamics/reference/iterate_matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"iterate transition matrices — iterate_matrix","text":"iterate_matrix can either act single transition matrix initial state (matrix 2D initial_state column vector), can simultaneously act n different matrices /n different initial states (matrix initial_state 3D arrays). latter case, first dimension objects batch dimension n. ensure matrix iterated specific number iterations, can set number niter, set tol 0 negative number ensure iterations stopped early.","code":""},{"path":"https://greta-dev.github.io/greta.dynamics/reference/iterate_matrix.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"iterate transition matrices — iterate_matrix","text":"greta vectorises across MCMC chains calculation greta array values, algorithm run chains (posterior samples), sites stages converged stable growth. single value converged iterations returned, value always value mcmc.list object. inspecting MCMC trace parameters tell whether iteration converged posterior samples, maximum number iterations required across samples","code":""},{"path":"https://greta-dev.github.io/greta.dynamics/reference/iterate_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"iterate transition matrices — iterate_matrix","text":"","code":"if (FALSE) { # simulate from a probabilistic 4-stage transition matrix model k <- 4  # component variables # survival probability for all stages survival <- uniform(0, 1, dim = k) # conditional (on survival) probability of staying in a stage stasis <- c(uniform(0, 1, dim = k - 1), 1) # marginal probability of staying/progressing stay <- survival * stasis progress <- (survival * (1 - stay))[1:(k - 1)] # recruitment rate for the largest two stages recruit <- exponential(c(3, 5))  # combine into a matrix: tmat <- zeros(k, k) diag(tmat) <- stay progress_idx <- row(tmat) - col(tmat) == 1 tmat[progress_idx] <- progress tmat[1, k - (1:0)] <- recruit  # analyse this to get the intrinsic growth rate and stable state iterations <- iterate_matrix(tmat) iterations$lambda iterations$stable_distribution iterations$all_states  # Can also do this simultaneously for a collection of transition matrices k <- 2 n <- 10 survival <- uniform(0, 1, dim = c(n, k)) stasis <- cbind(uniform(0, 1, dim = n), rep(1, n)) stay <- survival * stasis progress <- (survival * (1 - stasis))[, 1] recruit_rate <- 1 / seq(0.1, 5, length.out = n) recruit <- exponential(recruit_rate, dim = n) tmats <- zeros(10, 2, 2) tmats[, 1, 1] <- stasis[, 1] tmats[, 2, 2] <- stasis[, 2] tmats[, 2, 1] <- progress tmats[, 1, 2] <- recruit  iterations <- iterate_matrix(tmats) iterations$lambda iterations$stable_distribution iterations$all_states  }"},{"path":"https://greta-dev.github.io/greta.dynamics/reference/ode_solve.html","id":null,"dir":"Reference","previous_headings":"","what":"solve ODEs — ode_solve","title":"solve ODEs — ode_solve","text":"Solve system ordinary differential equations.","code":""},{"path":"https://greta-dev.github.io/greta.dynamics/reference/ode_solve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"solve ODEs — ode_solve","text":"","code":"ode_solve(derivative, y0, times, ..., method = c(\"ode45\", \"rk4\", \"midpoint\"))"},{"path":"https://greta-dev.github.io/greta.dynamics/reference/ode_solve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"solve ODEs — ode_solve","text":"derivative derivative function. first two arguments must 'y' 't', state parameter scalar timestep respectively. remaining parameters must named arguments representing (temporally static) model parameters. Variables distributions defined function. y0 greta array value state parameter y time 0 times column vector times evaluate y ... named arguments giving greta arrays additional (fixed) parameters method solver use. \"ode45\" uses adaptive step sizes, whilst \"rk4\" \"midpoint\" use fixed grid defined times; may faster less accurate \"ode45\".","code":""},{"path":"https://greta-dev.github.io/greta.dynamics/reference/ode_solve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"solve ODEs — ode_solve","text":"","code":"if (FALSE) { # replicate the Lotka-Volterra example from deSolve library (deSolve) LVmod <- function(Time, State, Pars) {   with(as.list(c(State, Pars)), {     Ingestion <- rIng  * Prey * Predator     GrowthPrey <- rGrow * Prey * (1 - Prey / K)     MortPredator <- rMort * Predator      dPrey <- GrowthPrey - Ingestion     dPredator <- Ingestion * assEff - MortPredator      return (list(c(dPrey, dPredator)))   }) }  pars  <- c(rIng = 0.2,  # /day, rate of ingestion            rGrow = 1.0,  # /day, growth rate of prey            rMort = 0.2,  # /day, mortality rate of predator            assEff = 0.5,  # -, assimilation efficiency            K = 10)  # mmol/m3, carrying capacity  yini  <- c(Prey = 1, Predator = 2) times <- seq(0, 30, by = 1) out   <- ode(yini, times, LVmod, pars)  # simulate observations jitter <- rnorm(2 * length(times), 0, 0.1) y_obs <- out[, -1] + matrix(jitter, ncol = 2)  # ~~~~~~~~~ # fit a greta model to infer the parameters from this simulated data  # greta version of the function lotka_volterra <- function(y, t, rIng, rGrow, rMort, assEff, K) {   Prey <- y[1, 1]   Predator <- y[1, 2]    Ingestion    <- rIng  * Prey * Predator   GrowthPrey   <- rGrow * Prey * (1 - Prey / K)   MortPredator <- rMort * Predator    dPrey        <- GrowthPrey - Ingestion   dPredator    <- Ingestion * assEff - MortPredator    cbind(dPrey, dPredator) }  # priors for the parameters rIng <- uniform(0, 2)  # /day, rate of ingestion rGrow <- uniform(0, 3)  # /day, growth rate of prey rMort <- uniform(0, 1)  # /day, mortality rate of predator assEff <- uniform(0, 1)  # -, assimilation efficiency K <- uniform(0, 30)  # mmol/m3, carrying capacity  # initial values and observation error y0 <- uniform(0, 5, dim = c(1, 2)) obs_sd <- uniform(0, 1)  # solution to the ODE y <- ode_solve(lotka_volterra, y0, times, rIng, rGrow, rMort, assEff, K)  # sampling statement/observation model distribution(y_obs) <- normal(y, obs_sd)  # we can use greta to solve directly, for a fixed set of parameters (the true # ones in this case) values <- c(list(y0 = t(1:2)),             as.list(pars)) vals <- calculate(y, values = values)[[1]] plot(vals[, 1] ~ times, type = \"l\", ylim = range(vals)) lines(vals[, 2] ~ times, lty = 2) points(y_obs[, 1] ~ times) points(y_obs[, 2] ~ times, pch = 2)  # or we can do inference on the parameters:  # build the model (takes a few seconds to define the tensorflow graph) m <- model(rIng, rGrow, rMort, assEff, K, obs_sd)  # compute MAP estimate o <- opt(m) o }"}]
